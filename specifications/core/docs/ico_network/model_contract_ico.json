{
  "best_practices": {
    "performance": [
      "Place related models in the same LD to minimize routing overhead",
      "Use geometric addressing for efficient lookups",
      "Configure bridge bandwidth based on expected traffic",
      "Cache routing tables for frequently accessed destinations"
    ],
    "scalability": [
      "Use hierarchical LD structures for large networks",
      "Create regional LDs with inter-regional bridges",
      "Implement load balancing across multiple LDs",
      "Monitor LD capacity and create new domains as needed"
    ],
    "security": [
      "Always use 'isolated' or 'private' security levels for sensitive models",
      "Create separate LDs for different security zones",
      "Use bridges with authentication for cross-LD communication",
      "Monitor routing tables for unexpected paths"
    ]
  },
  "ico_network_tools": {
    "description": "Tools for ICO network operations with Lorentzian Domain awareness",
    "tools": [
      {
        "description": "Create a new Lorentzian Domain for secure model placement",
        "name": "create_lorentzian_domain",
        "parameters": {
          "curvature": "number (default: 0.0)",
          "dimension": "integer (default: 4)",
          "metric_type": "enum: minkowski|schwarzschild|kerr|ads|custom",
          "name": "string",
          "security_level": "enum: public|protected|private|isolated"
        },
        "returns": "LorentzianDomain object with ld_id"
      },
      {
        "description": "Register this model as a node in an ICO network",
        "name": "register_model_node",
        "parameters": {
          "address_type": "enum: model|stack|block|network|service",
          "coordinates": "optional - custom coordinates in LD",
          "ld_id": "string - Lorentzian Domain ID"
        },
        "returns": "NodeAddress with routing information"
      },
      {
        "description": "Create a bridge between two Lorentzian Domains",
        "name": "create_ld_bridge",
        "parameters": {
          "bandwidth": "number (bytes/sec)",
          "bridge_type": "enum: wormhole|embedding|projection|fiber_bundle",
          "latency_bound": "number (seconds)",
          "source_ld_id": "string",
          "target_ld_id": "string"
        },
        "returns": "Bridge configuration"
      },
      {
        "description": "Compute route between two nodes in ICO network",
        "name": "compute_ico_route",
        "parameters": {
          "dest_node_id": "string",
          "source_node_id": "string"
        },
        "returns": "Route with hops, distance, and LD crossing information"
      },
      {
        "description": "List all nodes in a Lorentzian Domain",
        "name": "list_ld_nodes",
        "parameters": {
          "ld_id": "string - optional, lists all if not provided"
        },
        "returns": "List of node addresses"
      }
    ]
  },
  "usage_guidance": {
    "addressing": [
      "1. Node addresses are dynamic and LD-aware",
      "2. Coordinates are in Lorentzian spacetime (timelike + spacelike)",
      "3. Routing automatically handles LD boundaries",
      "4. Use routing_hints for optimization"
    ],
    "initial_setup": [
      "1. Create a secure Lorentzian Domain for your model",
      "2. Register yourself as a node in that domain",
      "3. Set security_level='isolated' for maximum privacy",
      "4. Use dimension=4 for standard spacetime, higher for complex networks"
    ],
    "multi_ld_operations": [
      "1. Create bridges between domains you need to communicate with",
      "2. Use bridge_type='wormhole' for fast, direct connections",
      "3. Use bridge_type='fiber_bundle' for structured, hierarchical connections",
      "4. Always compute routes before attempting cross-LD communication"
    ]
  }
}