{
  "specification": {
    "name": "Enhanced Spherical Exponential and Logarithmic Maps",
    "version": "1.0.0",
    "description": "Enhanced exponential and logarithmic map operations for spherical geometry with numerical stability improvements, antipodal point handling, and advanced features for HVS/AGUA integration.",
    "total_operations": 10,
    "format": "STUNIR",
    "tier_availability": "Core (Free)",
    "complexity_target": "O(n) or O(n log n)",
    "integration": ["HVS", "AGUA", "STUNIR"],
    "enhancements": [
      "Antipodal point handling",
      "Numerical stability for extreme cases",
      "Batch processing for efficiency",
      "Jacobian computation for optimization",
      "Holonomy computation"
    ]
  },
  "mathematical_foundations": {
    "exponential_map": {
      "description": "Maps tangent vectors to sphere via great circles",
      "formula": "exp_x(v) = cos(||v||)x + sin(||v||)(v/||v||)",
      "properties": ["Periodic (period 2π)", "Smooth", "Great circle flow"],
      "injectivity_radius": "π"
    },
    "logarithmic_map": {
      "description": "Inverse of exponential map",
      "formula": "log_x(y) = (arccos(⟨x,y⟩)/||y-⟨y,x⟩x||)(y-⟨y,x⟩x)",
      "properties": ["Inverse of exp", "Singular at antipodal point", "Tangent vector output"],
      "singularity": "Antipodal point x' = -x"
    }
  },
  "operations": [
    {
      "id": "spherical_exp_map_stable",
      "name": "Stable Spherical Exponential Map",
      "category": "core_operations",
      "description": "Numerically stable exponential map with Taylor expansion for small tangent vectors and modular arithmetic for large vectors",
      "formula": "exp_x(v) with adaptive precision and periodicity handling",
      "input": {
        "x": "Base point on sphere Sⁿ (unit vector)",
        "v": "Tangent vector at x (⟨x,v⟩ = 0)",
        "epsilon": "Threshold for Taylor expansion (default: 1e-8)",
        "handle_periodicity": "Reduce ||v|| modulo 2π (default: true)"
      },
      "output": {
        "point": "Point on sphere Sⁿ",
        "numerical_method": "Method used ('standard', 'taylor', 'periodic')"
      },
      "complexity": "O(n)",
      "precision": "1e-15",
      "implementation_notes": [
        "Use Taylor expansion for ||v|| < epsilon: exp_x(v) ≈ x + v - (1/2)||v||²x",
        "Reduce ||v|| modulo 2π for periodicity",
        "Use standard formula for epsilon ≤ ||v|| < π",
        "Validate output constraint ||exp_x(v)|| = 1"
      ],
      "test_cases": [
        {
          "name": "tiny_tangent",
          "v_norm": "1e-12",
          "expected_method": "taylor"
        },
        {
          "name": "normal_tangent",
          "v_norm": "1.0",
          "expected_method": "standard"
        },
        {
          "name": "large_tangent",
          "v_norm": "7.0",
          "expected_method": "periodic",
          "expected_reduced_norm": "7.0 - 2π ≈ 0.717"
        }
      ],
      "edge_cases": [
        "Zero tangent vector",
        "Very small tangent vectors (||v|| < 1e-15)",
        "Tangent vectors with ||v|| > 2π",
        "Tangent vectors with ||v|| ≈ π (antipodal)"
      ]
    },
    {
      "id": "spherical_log_map_stable",
      "name": "Stable Spherical Logarithmic Map with Antipodal Handling",
      "category": "core_operations",
      "description": "Numerically stable logarithmic map with special handling for antipodal points and nearby points",
      "formula": "log_x(y) with antipodal detection and resolution",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "y": "Target point on sphere Sⁿ",
        "epsilon": "Threshold for nearby points (default: 1e-8)",
        "antipodal_epsilon": "Threshold for antipodal detection (default: 1e-6)",
        "antipodal_resolution": "Method for antipodal case ('error', 'arbitrary', 'specified')",
        "antipodal_direction": "Specified direction for antipodal case (if resolution='specified')"
      },
      "output": {
        "tangent_vector": "Tangent vector at x (or null if antipodal and resolution='error')",
        "numerical_method": "Method used ('standard', 'nearby', 'antipodal')",
        "is_antipodal": "Boolean indicating if y is antipodal to x"
      },
      "complexity": "O(n)",
      "precision": "1e-15",
      "implementation_notes": [
        "Check if ⟨x,y⟩ ≈ -1 (antipodal)",
        "If antipodal: handle based on resolution strategy",
        "Use Taylor expansion for ⟨x,y⟩ ≈ 1 (nearby)",
        "Use standard formula otherwise",
        "Validate tangent constraint ⟨x, log_x(y)⟩ = 0"
      ],
      "test_cases": [
        {
          "name": "nearby_points",
          "inner_product": "0.9999999",
          "expected_method": "nearby"
        },
        {
          "name": "normal_distance",
          "inner_product": "0.5",
          "expected_method": "standard"
        },
        {
          "name": "antipodal_points",
          "inner_product": "-0.9999999",
          "expected_method": "antipodal",
          "is_antipodal": true
        }
      ],
      "edge_cases": [
        "Identical points (⟨x,y⟩ = 1)",
        "Antipodal points (⟨x,y⟩ = -1)",
        "Nearly antipodal points"
      ]
    },
    {
      "id": "spherical_exp_map_batch",
      "name": "Batch Spherical Exponential Map",
      "category": "batch_operations",
      "description": "Compute exponential map for multiple tangent vectors efficiently",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "tangent_vectors": "Array of tangent vectors at x",
        "parallel": "Enable parallel processing (default: true)"
      },
      "output": {
        "points": "Array of points on sphere Sⁿ"
      },
      "complexity": "O(m·n) where m=num_vectors",
      "precision": "1e-15",
      "implementation_notes": [
        "Vectorize operations for efficiency",
        "Use parallel processing for large batches",
        "Reuse computed values (cos, sin, norms)",
        "Batch validation of constraints"
      ]
    },
    {
      "id": "spherical_log_map_batch",
      "name": "Batch Spherical Logarithmic Map",
      "category": "batch_operations",
      "description": "Compute logarithmic map for multiple target points efficiently with antipodal handling",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "target_points": "Array of target points",
        "antipodal_resolution": "Method for antipodal cases",
        "parallel": "Enable parallel processing (default: true)"
      },
      "output": {
        "tangent_vectors": "Array of tangent vectors at x",
        "antipodal_flags": "Boolean array indicating antipodal points"
      },
      "complexity": "O(m·n) where m=num_points",
      "precision": "1e-15",
      "implementation_notes": [
        "Vectorize operations for efficiency",
        "Use parallel processing for large batches",
        "Batch antipodal detection",
        "Handle antipodal cases consistently"
      ]
    },
    {
      "id": "spherical_exp_map_jacobian",
      "name": "Spherical Exponential Map Jacobian",
      "category": "differential_operations",
      "description": "Compute Jacobian matrix of exponential map for optimization",
      "formula": "J_exp(v) = ∂exp_x(v)/∂v",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "v": "Tangent vector at x"
      },
      "output": {
        "jacobian": "Jacobian matrix (n×n)",
        "determinant": "Determinant of Jacobian (optional)"
      },
      "complexity": "O(n²)",
      "precision": "1e-12",
      "implementation_notes": [
        "Analytical formula: J = cos(||v||)I + (sin(||v||)/||v|| - cos(||v||))(v⊗v)/||v||²",
        "Handle ||v|| = 0 case",
        "Exploit structure for efficiency"
      ],
      "applications": [
        "Riemannian optimization on sphere",
        "Gradient descent on manifolds",
        "Uncertainty propagation"
      ]
    },
    {
      "id": "spherical_log_map_jacobian",
      "name": "Spherical Logarithmic Map Jacobian",
      "category": "differential_operations",
      "description": "Compute Jacobian matrix of logarithmic map",
      "formula": "J_log(y) = ∂log_x(y)/∂y",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "y": "Target point on sphere Sⁿ"
      },
      "output": {
        "jacobian": "Jacobian matrix (n×n)",
        "determinant": "Determinant of Jacobian (optional)",
        "is_singular": "Boolean indicating singularity (antipodal case)"
      },
      "complexity": "O(n²)",
      "precision": "1e-12",
      "implementation_notes": [
        "Singular at antipodal point",
        "Use analytical formula when available",
        "Handle near-antipodal points carefully"
      ]
    },
    {
      "id": "spherical_parallel_transport_holonomy",
      "name": "Spherical Parallel Transport with Holonomy",
      "category": "transport_operations",
      "description": "Parallel transport with holonomy computation for closed loops",
      "input": {
        "v": "Tangent vector to transport",
        "path": "Array of points defining path on sphere",
        "closed_loop": "Boolean indicating if path is closed"
      },
      "output": {
        "transported_vector": "Final transported vector",
        "holonomy_angle": "Holonomy angle for closed loop (if applicable)",
        "intermediate_vectors": "Transported vectors at each point (optional)"
      },
      "complexity": "O(m·n) where m=path_length",
      "precision": "1e-12",
      "implementation_notes": [
        "Transport along geodesic segments",
        "Compute holonomy for closed loops",
        "Holonomy angle = enclosed solid angle (Gauss-Bonnet)",
        "Validate norm preservation"
      ],
      "applications": [
        "Geometric phase computation",
        "Curvature visualization",
        "Topological analysis"
      ]
    },
    {
      "id": "spherical_retraction",
      "name": "Spherical Retraction",
      "category": "optimization_operations",
      "description": "First-order retraction approximation to exponential map",
      "formula": "R_x(v) = (x + v)/||x + v||",
      "input": {
        "x": "Base point on sphere Sⁿ",
        "v": "Tangent vector at x"
      },
      "output": {
        "point": "Point on sphere Sⁿ (approximate)"
      },
      "complexity": "O(n)",
      "precision": "1e-6 (lower than exp_map)",
      "implementation_notes": [
        "Simple normalization",
        "Faster than exponential map",
        "First-order approximation",
        "Useful for optimization"
      ],
      "applications": [
        "Riemannian optimization (line search)",
        "Gradient descent iterations",
        "Real-time applications"
      ]
    },
    {
      "id": "spherical_slerp",
      "name": "Spherical Linear Interpolation (SLERP)",
      "category": "interpolation_operations",
      "description": "Smooth interpolation along great circle using exp/log maps",
      "formula": "slerp(x,y,t) = exp_x(t·log_x(y))",
      "input": {
        "x": "Start point on sphere Sⁿ",
        "y": "End point on sphere Sⁿ",
        "t": "Interpolation parameter in [0,1]",
        "handle_antipodal": "Method for antipodal case"
      },
      "output": {
        "point": "Interpolated point on sphere Sⁿ"
      },
      "complexity": "O(n)",
      "precision": "1e-12",
      "implementation_notes": [
        "Equivalent to geodesic interpolation",
        "Handle antipodal case",
        "Constant angular velocity",
        "Widely used in computer graphics"
      ],
      "test_cases": [
        {
          "name": "t_equals_0",
          "t": "0.0",
          "expected": "x"
        },
        {
          "name": "t_equals_1",
          "t": "1.0",
          "expected": "y"
        },
        {
          "name": "midpoint",
          "t": "0.5",
          "expected": "midpoint on great circle"
        }
      ]
    },
    {
      "id": "spherical_shooting_method",
      "name": "Spherical Shooting Method",
      "category": "geodesic_operations",
      "description": "Find tangent vector that shoots from x to y using iterative refinement",
      "formula": "Find v such that exp_x(v) = y",
      "input": {
        "x": "Start point on sphere Sⁿ",
        "y": "Target point on sphere Sⁿ",
        "max_iterations": "Maximum iterations (default: 20)",
        "tolerance": "Convergence tolerance (default: 1e-10)"
      },
      "output": {
        "tangent_vector": "Tangent vector v such that exp_x(v) ≈ y",
        "converged": "Boolean indicating convergence",
        "iterations": "Number of iterations used",
        "final_error": "Final error ||exp_x(v) - y||"
      },
      "complexity": "O(k·n²) where k=iterations",
      "precision": "1e-10",
      "implementation_notes": [
        "Initialize with log_x(y)",
        "Use Newton's method with Jacobian",
        "Handle antipodal case",
        "Converges quadratically"
      ],
      "applications": [
        "Validation of log_map implementation",
        "High-precision geodesic computation",
        "Inverse problems"
      ]
    }
  ],
  "antipodal_handling_strategies": {
    "error": {
      "description": "Return error/null for antipodal points",
      "use_case": "When antipodal case is unexpected"
    },
    "arbitrary": {
      "description": "Return arbitrary tangent vector with ||v|| = π",
      "use_case": "When any direction is acceptable",
      "implementation": "Choose random orthogonal direction"
    },
    "specified": {
      "description": "Use user-specified direction",
      "use_case": "When specific direction is required",
      "implementation": "Project specified direction to tangent space"
    },
    "shortest": {
      "description": "Return shortest path (may be non-unique)",
      "use_case": "When shortest distance is priority"
    }
  },
  "numerical_stability_guidelines": {
    "small_vectors": {
      "threshold": "||v|| < 1e-8",
      "method": "Taylor expansion",
      "formula": "exp_x(v) ≈ x + v - (1/2)||v||²x"
    },
    "antipodal_points": {
      "threshold": "⟨x,y⟩ < -0.999999",
      "method": "Special handling",
      "notes": "Logarithmic map is singular"
    },
    "periodicity": {
      "threshold": "||v|| > 2π",
      "method": "Modular reduction",
      "formula": "||v|| mod 2π"
    }
  },
  "performance_optimization": {
    "batch_processing": "Use vectorized operations for multiple vectors",
    "parallel_processing": "Enable parallelization for large batches",
    "caching": "Cache frequently computed values (cos, sin, norms, inner products)",
    "antipodal_detection": "Early detection to avoid unnecessary computation"
  }
}
